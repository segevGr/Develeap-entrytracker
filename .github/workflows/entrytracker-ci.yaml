name: entrytracker-ci

on:
  push:
    branches: ["main"]
    paths-ignore:
      - "README.md"
  workflow_dispatch:

permissions:
  contents: write
  id-token: write

jobs:
  building_and_unit_testing:
    runs-on: ubuntu-latest
    name: Building and Unit Testing
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Install dependencies
        run: pip install --no-cache-dir -r requirements.txt

      - name: Run app
        run: python app.py &

      - name: Testing
        uses: ./.github/actions/retry
        with:
          command: curl -s http://localhost:5000/ | grep current_entry

      - name: Cleanup
        run: pkill -f "python app.py" || true

  packaging_e2e_testing_and_publish:
    runs-on: ubuntu-latest
    name: Packaging E2E Testing and Publish
    needs: building_and_unit_testing
    outputs:
      new_tag: ${{ steps.version.outputs.new_tag }}

    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          fetch-tags: true

      - uses: docker/setup-buildx-action@v3

      - name: Building
        uses: docker/build-push-action@v6
        with:
          context: .
          push: false
          load: true
          tags: entrytracker:temp
          cache-from: type=gha
          cache-to: type=gha,mode=max

      - name: Run Docker Compose
        env:
          DB_HOST: ${{ secrets.DB_HOST }}
          DB_USER: ${{ secrets.DB_USER }}
          DB_PASSWORD: ${{ secrets.DB_PASSWORD }}
          DB_NAME: ${{ secrets.DB_NAME }}
        run: docker compose up -d

      - name: Wait for MySQL
        uses: ./.github/actions/retry
        with:
          command: docker exec $(docker ps -q --filter name=mysql) mysqladmin ping -h localhost
          max_attempts: 5
          retry_wait_seconds: 15

      - name: Wait for Nginx health
        uses: ./.github/actions/retry
        with:
          command: curl -s http://localhost:80/health | grep ok

      - name: Testing
        uses: ./.github/actions/retry
        with:
          command: curl -s http://localhost:80/ | grep previous_entries

      - name: Cleanup
        run: docker compose down

      - name: Fetch tag
        id: version
        uses: ./.github/actions/version-increment

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ secrets.AWS_ECR_ROLE }}
          aws-region: ap-south-1

      - name: Login to Amazon ECR
        uses: aws-actions/amazon-ecr-login@v2

      - name: Run push command
        env:
          TAG: ${{steps.version.outputs.new_tag}}
        run: |
          docker tag entrytracker:temp ${{ secrets.ECR_URL }}:$TAG
          docker push ${{ secrets.ECR_URL }}:$TAG

  deploy:
    runs-on: ubuntu-latest
    name: Deploy
    needs: packaging_e2e_testing_and_publish
    env:
      Tag: ${{ needs.packaging_e2e_testing_and_publish.outputs.new_tag }}

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Backup previous compose
        uses: appleboy/ssh-action@v1.0.0
        with:
          host: ${{ secrets.EC2_HOST }}
          username: ${{ secrets.EC2_USER }}
          key: ${{ secrets.EC2_SSH_KEY }}
          script: |
            if [ -f ~/compose.yaml ]; then
              cp ~/compose.yaml ~/compose_previous.yaml
            fi

      - name: Upload docker compose to EC2
        uses: appleboy/scp-action@v0.1.7
        with:
          host: ${{ secrets.EC2_HOST }}
          username: ${{ secrets.EC2_USER }}
          key: ${{ secrets.EC2_SSH_KEY }}
          source: "compose.yaml,nginx.conf"
          target: "~"

      - name: Connection with ssh to ec2
        uses: appleboy/ssh-action@v1.0.0
        env:
          DB_HOST: ${{ secrets.DB_HOST }}
          DB_USER: ${{ secrets.DB_USER }}
          DB_PASSWORD: ${{ secrets.DB_PASSWORD }}
          DB_NAME: ${{ secrets.DB_NAME }}
        with:
          host: ${{ secrets.EC2_HOST }}
          username: ${{ secrets.EC2_USER }}
          key: ${{ secrets.EC2_SSH_KEY }}
          envs: DB_HOST,DB_USER,DB_PASSWORD,DB_NAME
          script: |
            sudo apt-get update -y

            if ! command -v curl &> /dev/null; then
              sudo apt-get install -y curl
            fi

            if ! command -v unzip &> /dev/null; then
              sudo apt-get install -y unzip
            fi

            if ! command -v docker &> /dev/null; then
              curl -fsSL https://get.docker.com -o get-docker.sh
              sh get-docker.sh
            fi

            if [ -S /var/run/docker.sock ]; then
              sudo chmod 666 /var/run/docker.sock
            fi

            if ! command -v aws &> /dev/null; then
              curl "https://awscli.amazonaws.com/awscli-exe-linux-x86_64.zip" -o "awscliv2.zip"
              unzip -o awscliv2.zip
              sudo ./aws/install
            fi

            if ! docker compose version &> /dev/null; then
              DOCKER_CONFIG=${DOCKER_CONFIG:-$HOME/.docker}
              mkdir -p $DOCKER_CONFIG/cli-plugins
              curl -SL https://github.com/docker/compose/releases/download/v2.29.2/docker-compose-linux-x86_64 \
                -o $DOCKER_CONFIG/cli-plugins/docker-compose
              chmod +x $DOCKER_CONFIG/cli-plugins/docker-compose
            fi

            docker --version
            docker compose version
            aws --version
            curl --version

            aws ecr get-login-password --region ap-south-1 \
              | docker login --username AWS --password-stdin ${{ secrets.ECR_URL }}

            sed -i "s|entrytracker:temp|${{ secrets.ECR_URL }}:${{ env.Tag }}|g" ~/compose.yaml
            sed -i '/^[[:space:]]*build:/,/^[[:space:]]*[^[:space:]]/ { /^[[:space:]]*build:/d; /^[[:space:]]*context:/d }' ~/compose.yaml

            if docker network inspect entryTracker-network >/dev/null 2>&1; then
              sed -i '/entryTracker-network:/,/^[[:space:]]*[^[:space:]]/c\  entryTracker-network:\n    external: true' ~/compose.yaml
            fi

            docker compose -f ~/compose.yaml up -d

      - name: Push new version to github
        run: |
          git tag ${{ env.Tag }}
          git push origin ${{ env.Tag }}

      - name: Rollback if deploy fails
        if: failure()
        uses: appleboy/ssh-action@v1.0.0
        with:
          host: ${{ secrets.EC2_HOST }}
          username: ${{ secrets.EC2_USER }}
          key: ${{ secrets.EC2_SSH_KEY }}
          script: |
            echo "Rolling back to previous version..."
            if [ -f ~/compose_previous.yaml ]; then
              docker compose -f ~/compose_previous.yaml up -d
            else
              echo "No previous compose.yaml found, nothing to rollback to."
            fi

  notify:
    runs-on: ubuntu-latest
    name: Notify
    needs:
      [building_and_unit_testing, packaging_e2e_testing_and_publish, deploy]
    env:
      BUILD_RESULT: ${{ needs.building_and_unit_testing.result }}
      PUBLISH_RESULT: ${{ needs.packaging_e2e_testing_and_publish.result }}
      DEPLOY_RESULT: ${{ needs.deploy.result }}
    if: always()

    steps:
      - name: Detect failure cause
        id: result
        run: |
          status="success"
          failed=""
          readable=""

          if [ "$BUILD_RESULT" = "failure" ]; then
            status="failure"
            readable="Building & Unit Testing"
          elif [ "$PUBLISH_RESULT" = "failure" ]; then
            status="failure"
            readable="Packaging, E2E Testing & Publish"
          elif [ "$DEPLOY_RESULT" = "failure" ]; then
            status="failure"
            readable="Deploy"
          fi

          echo "workflow_status=$status" >> $GITHUB_OUTPUT
          echo "failed_job=$readable" >> $GITHUB_OUTPUT

      - name: Send email
        uses: dawidd6/action-send-mail@v3
        with:
          server_address: ${{ secrets.SMTP_ADDRESS }}
          server_port: ${{ secrets.SMTP_PORT }}
          username: ${{ secrets.SMTP_USER }}
          password: ${{ secrets.SMTP_PASS }}
          subject: "Workflow ${{ steps.result.outputs.workflow_status }}"
          to: ${{ github.event.pusher.email }},segev.grotas@gmail.com
          from: "GitHub Actions <${{ secrets.SMTP_USER }}> "
          body: |
            Workflow result: ${{ steps.result.outputs.workflow_status }}
            ${{ steps.result.outputs.failed_job != '' && format('Failed job: {0}', steps.result.outputs.failed_job) || 'All jobs passed successfully.' }}
            Logs: ${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}
